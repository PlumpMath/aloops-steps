# Aprendizaje

## Relacionado con la modificación de la librería quil.

Para poder usar quil+oscp5 juan ha modificado la librería original de oscp5.

```
(defn -oscEvent
  ([this message]
   (println "osc message received! Message: " message)
   (println "addrpattern:" (.addrPattern message))
   (println "typetag:" (.typetag message))
   (with-applet this
     ((:osc-event (.state this)) message))))
```
He añadido más `(println)` para tener más información sobre lo que se está recibiendo: para saber cuál es el path y el typetag.

El nombre de la función está precedido por un guión:
It's the default prefix for methods in classes generated by gen-class.

```
(gen-interface
 :name quil.OscP5
 :methods [[oscEvent [oscP5.OscMessage] Object]])
```
Esto genera la interfaz `quil.OscP5`.

Docs about gen-interface:

When compiling, **gen-interface** generates compiled bytecode for an interface with the given package-qualified :name, and writes the .class file to the *compile-path* directory. When not compiling, does nothing.
Options should be a set of key/value pairs, all except for :name are
optional:
- **:name a name**  (The package-qualified name of the class to be generated)
- **:extends [interface ...]** (One or more interfaces, which will be extended by this interface.)
- **:methods [ [name [param-types] return-type], ...]**
 (This parameter is used to specify the signatures of the methods of
the generated interface. Do not repeat superinterface signatures
here.)


```
 (gen-class
  :name "quil.Applet"
  :implements [clojure.lang.IMeta quil.OscP5]
  ...)
```
Añadimos `quil.OscP5` (que acabamos de crear con `gen-interface`) a la lista de interfaces, cuyos métodos serán implementados por la clase `quil.Applet` generada por gen-class.

```

(defn applet
   ...
   osc-event-fn      (or (:osc-event options) (fn [message] (println "default osc-event")))
   ...
   applet-state      (merge options
                                 {:state state
                                  :looping? looping?
                                  :on-close on-close-fn
                                  :setup-fn setup-fn
                                  :settings-fn settings-fn
                                  :draw-fn draw-fn
                                  :osc-event osc-event-fn
                                  :renderer renderer
                                  :size size
                                  :display (:display options)
                                  :target-frame-rate (atom 60)
                                  :key-event (atom nil)}
                                 listeners)
 ...)
 ```
Con esta modificación se puede añadir una opción nueva a defsketch o sketch, :osc-event. La función que se le asigne será la que se ejecute cada vez que se reciba un mensaje osc.

Una vez realizadas las modificaciones, para que se pueda usar la librería, es necesario hacer `lein install` en el su directorio. Es recomendable hacer antes `lein clean`.

### Cuestiones que no he averiguado todavía:

- En `project.clj` del proyecto en el que queremos usar la librería, en `:dependencies`, no sé si hay que poner `[quil "2.4.0-osc"]` o `[quil/quil "2.4.0-osc"]`.
Juan lo pone así: `[quil/quil "2.0.1-juan"]`, pero cuando se especifica la librería original, es así: `[quil "2.4.0"]`
He probado a ponerlo de las dos maneras y parece que funciona, aunque no sé si algún error de los que me están dando tiene algo que ver con eso.

- En `project.clj` de la librería en `:resource-paths`, hay que añadir `"lib/oscP5.jar"` Y en la carpeta del proyecto debe haber una carpeta llamada `lib`, en la que se encuentra el archivo `oscP5.jar`

- Otra diferencia es que Juan no especifica `[de.sojamo/oscp5 "0.9.8"]` en el `project.clj` del proyecto en el que queremos usar la librería, en `:dependencies`. Y sin embargo si yo no lo incluyo me da error, me da un `java.lang.ClassNotFoundException oscP5.OscP5.`
Tiene todo esto alguna relación con `:resource-paths`?

- Creo que he descubierto el porqué de los dos anteriores puntos:

  "Leiningen 1 expanded glob patterns assigned to :resource-path, which allowed us to add jars to a local directory e.g. lib/jars, set :resource-path to "lib/jars/\*", and lein would add those jars to the classpath.

  Leiningen 2 does not support this usage out of the box in order to support the principle that builds should be repeatable (see https://github.com/technomancy/leiningen/wiki/Repeatability)."

  Sacado de la página: https://github.com/dchelimsky/lein-expand-resource-paths

  Por eso ahora, la única manera de acceder a oscP5 es colocando `[de.sojamo/oscp5 "0.9.8"]` en `:dependencies`

- Todavía no consigo que los mensajes recibidos sean parseados.
Al añadir más `(println)` en `quil-osc`he podido comparar los mensajes que me llegan en mi proyecto de prueba con los que envía la librería de Juan. Y hay una diferencia.

  En el proyecto de Juan es:
`#<OscMessage /127.0.0.1:9000 | /live/name/clip/done s>`
Que es un objeto de la clase `oscP5.OscMessage`

  En mi proyecto lo que llega es:
`#object[oscP5.OscMessage 0x6c2ec80b /127.0.0.1:9000 | /live/name/clip/done s]`
Que es también un objeto de la clase `oscP5.OscMessage`. ¿Qué implica entonces la diferencia en la forma de escribirse?

- Me he dado cuenta de que hay más diferencias en la forma de imprimir los objetos en la consola. He ampliado lo que imprime la función `(defn -oscEvent ...)` para obtener más información y compararla con la de la librería de Juan.

  Quería saber qué imprime `(:osc-event (.state this))`, que debería ser la función que hemos asociado a `:osc-event` en el defsketch y que se aplica a message. El resultado es:

  ```
#object[quil.middlewares.bind_output$bind_output$iter__148__152$fn__153$fn__164  0x5b739890
quil.middlewares.bind_output$bind_output$iter__148__152$fn__153$fn__164@5b739890]
```

  Que me ha parecido muy raro, pero no sólo representa así esa función, sino todas. Por ejemplo, la asociada a `:mouse-clicked`es

  ```
  #object[quil.middlewares.bind_output$bind_output$iter__148__152$fn__153$fn__164 0x186a5fac
  quil.middlewares.bind_output$bind_output$iter__148__152$fn__153$fn__164@186a5fac]
```

  En el caso de la librería de Juan, al imprimir las funciones, lo hace con nombres reconocibles, por ejemplo, la función asociada a `:osc-event` es:

  ```
#'dat00.antropoloops/process-osc-event
```

- He descubierto donde estaba el problema. La nueva biblioteca de quil (versión 2.4.0) usa middlewares y dos de ellos estaban relacionados con el error. Los cambios realizados están en `bind_output.clj` y en `safe_fns.clj`.

  `safe-fns` Wraps all functions in options such that they will not throw exceptions. El tema es que en la librería la mayoría de las fns no toman argumentos, a excepción de una, `:mouse-wheel`. La fn que nosotros hemos añadido sí toma un argumento, pero al no ser `:mouse-wheel` que era la única excepción especificada, se le aplicaba `wrap-fn`, que invoca la función sin argumentos. Por eso, el `try-catch` que había añadido en `oscEvent` me daba un error del tipo `wrong arity`

- Al final, después de cambiar la librería, consigo recibir el mensaje e imprimirlo en consola en la repl, pero no lo veía en lighttable. Creo que tiene que ver con
`bind_output.clj`. Así que al final en `:features` he añadido la opción `:no-bind-output` y ahora sí puedo ver los mensajes recibidos escritos en la consola de lighttable.

## Cómo saber los procesos que la JVM tiene abiertos

Abrir consola en `C:\Program Files\Java\jdk1.7.0_65\bin`
Ejecutar `jps`
Es útil porque a veces cuando nos conectamos a la JVM y cerramos una ventana de quil, no se cierra el proceso (depende de si la opción `:exit-on-close` está activa o no). Con `jps` podemos saber si hay procesos que se han quedado abiertos, sobre todo si estamos ejecutando desde la línea de comandos (desde lighttable es fácil ver si hay conexiones abiertas, ya que se ve en la ventana de connections).

Para terminar un proceso manualmente:

`(taskkill /F /PID [PID del proceso])`

Por ejemplo:

`(taskkill /F /PID 8502)`



















